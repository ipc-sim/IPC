//
//  BarrierFunctions.hpp
//  IPC
//
//  Created by Minchen Li on 6/19/19.
//

namespace IPC {

inline void b_C0(double d, double dHat, double& b)
{
    b = -log(d / dHat);
}

inline void g_bC0(double d1, double& g)
{
    /* G_BC0 */
    /*     G = G_BC0(D1,MU1) */
    /*     This function was generated by the Symbolic Math Toolbox version 8.3. */
    /*     19-Jun-2019 15:09:45 */
    g = -1.0 / d1;
}

inline void H_bC0(double d1, double& H)
{
    /* H_BC0 */
    /*     H = H_BC0(D1,MU1) */
    /*     This function was generated by the Symbolic Math Toolbox version 8.3. */
    /*     19-Jun-2019 15:09:45 */
    H = 1.0 / (d1 * d1);
}

inline void b_C1(double d, double dHat, double& b)
{
    b = (d - dHat) * log(d / dHat);
}

inline void g_bC1(double d1, double dHat1, double& g)
{
    /* G_BC1 */
    /*     G = G_BC1(D1,DHAT1,MU1) */
    /*     This function was generated by the Symbolic Math Toolbox version 8.3. */
    /*     27-Dec-2019 15:54:45 */
    g = std::log(d1 / dHat1) + (d1 - dHat1) / d1;
}

inline void H_bC1(double d1, double dHat1, double& H)
{
    /* H_BC1 */
    /*     H = H_BC1(D1,DHAT1,MU1) */
    /*     This function was generated by the Symbolic Math Toolbox version 8.3. */
    /*     27-Dec-2019 15:54:46 */
    H = 2.0 / d1 - 1.0 / (d1 * d1) * (d1 - dHat1);
}

inline void b_C2(double d, double dHat, double& b)
{
    b = -(d - dHat) * (d - dHat) * log(d / dHat);
}

inline void g_bC2(double d1, double dHat1, double& g)
{
    double t2;

    /* G_BC2 */
    /*     G = G_BC2(D1,DHAT1,MU1) */
    /*     This function was generated by the Symbolic Math Toolbox version 8.3. */
    /*     19-Jun-2019 15:02:54 */
    t2 = d1 - dHat1;
    g = t2 * std::log(d1 / dHat1) * -2.0 - (t2 * t2) / d1;
}

inline void H_bC2(double d1, double dHat1, double& H)
{
    double t2;

    /* H_BC2 */
    /*     H = H_BC2(D1,DHAT1,MU1) */
    /*     This function was generated by the Symbolic Math Toolbox version 8.3. */
    /*     19-Jun-2019 15:02:54 */
    t2 = d1 - dHat1;
    H = (std::log(d1 / dHat1) * -2.0 - t2 * 4.0 / d1) + 1.0 / (d1 * d1) * (t2 * t2);
}

inline void compute_b(double d, double dHat, double& b)
{
    if constexpr (BARRIER_FUNC_TYPE == 0) {
        b_C0(d, dHat, b);
    }
    else if (BARRIER_FUNC_TYPE == 1) {
        b_C1(d, dHat, b);
    }
    else if (BARRIER_FUNC_TYPE == 2) {
        b_C2(d, dHat, b);
    }
    else {
        std::cout << "needs to define BARRIER_FUNC_TYPE to be 0 (C0 clamped log) or 2 (C2 clamped log)" << std::endl;
    }
}

inline void compute_g_b(double d, double dHat, double& g)
{
    if constexpr (BARRIER_FUNC_TYPE == 0) {
        g_bC0(d, g);
    }
    else if (BARRIER_FUNC_TYPE == 1) {
        g_bC1(d, dHat, g);
    }
    else if (BARRIER_FUNC_TYPE == 2) {
        g_bC2(d, dHat, g);
    }
    else {
        std::cout << "needs to define BARRIER_FUNC_TYPE to be 0 (C0 clamped log) or 2 (C2 clamped log)" << std::endl;
    }
}

inline void compute_H_b(double d, double dHat, double& H)
{
    if constexpr (BARRIER_FUNC_TYPE == 0) {
        H_bC0(d, H);
    }
    else if (BARRIER_FUNC_TYPE == 1) {
        H_bC1(d, dHat, H);
    }
    else if (BARRIER_FUNC_TYPE == 2) {
        H_bC2(d, dHat, H);
    }
    else {
        std::cout << "needs to define BARRIER_FUNC_TYPE to be 0 (C0 clamped log) or 2 (C2 clamped log)" << std::endl;
    }
}

} // namespace IPC